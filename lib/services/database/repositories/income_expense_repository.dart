import 'package:sqflite/sqflite.dart';
import '../../../models/income_expense_entry.dart';
import '../database_connection.dart';
import '../../../utils/logger.dart';

/// Repository for income/expense entry database operations
/// Handles all SQLite operations for financial entry management
class IncomeExpenseRepository {
  final DatabaseConnection _dbConnection = DatabaseConnection();

  static const String tableName = 'income_expense_entries';
  static const String columnId = 'id';
  static const String columnDescription = 'description';
  static const String columnAmount = 'amount';
  static const String columnType = 'type';
  static const String columnDate = 'date';
  static const String columnCategory = 'category';
  static const String columnIsAutoGenerated = 'is_auto_generated';
  static const String columnCreatedAt = 'created_at';
  static const String columnUpdatedAt = 'updated_at';

  /// Create income/expense entries table
  static Future<void> createTable(Database db) async {
    await db.execute('''
      CREATE TABLE IF NOT EXISTS $tableName (
        $columnId TEXT PRIMARY KEY,
        $columnDescription TEXT NOT NULL,
        $columnAmount REAL NOT NULL,
        $columnType TEXT NOT NULL,
        $columnDate TEXT NOT NULL,
        $columnCategory TEXT NOT NULL,
        $columnIsAutoGenerated INTEGER NOT NULL DEFAULT 0,
        $columnCreatedAt TEXT NOT NULL,
        $columnUpdatedAt TEXT NOT NULL
      )
    ''');

    Logger.info('Income/expense entries table created successfully', tag: 'INCOME_EXPENSE_REPOSITORY');
  }

  /// Get all income/expense entries
  Future<List<IncomeExpenseEntry>> getAllEntries() async {
    try {
      final db = await _dbConnection.database;
      final List<Map<String, dynamic>> maps = await db.query(
        tableName,
        orderBy: '$columnDate DESC',
      );

      final entries = maps.map((map) => _mapToModel(map)).toList();
      Logger.info('Retrieved ${entries.length} income/expense entries', tag: 'INCOME_EXPENSE_REPOSITORY');
      return entries;
    } catch (e) {
      Logger.error('Failed to get income/expense entries', tag: 'INCOME_EXPENSE_REPOSITORY', error: e);
      rethrow;
    }
  }

  /// Get entries by type (income or expense)
  Future<List<IncomeExpenseEntry>> getEntriesByType(String type) async {
    try {
      final db = await _dbConnection.database;
      final List<Map<String, dynamic>> maps = await db.query(
        tableName,
        where: '$columnType = ?',
        whereArgs: [type],
        orderBy: '$columnDate DESC',
      );

      final entries = maps.map((map) => _mapToModel(map)).toList();
      Logger.info('Retrieved ${entries.length} $type entries', tag: 'INCOME_EXPENSE_REPOSITORY');
      return entries;
    } catch (e) {
      Logger.error('Failed to get $type entries', tag: 'INCOME_EXPENSE_REPOSITORY', error: e);
      rethrow;
    }
  }

  /// Get income entries
  Future<List<IncomeExpenseEntry>> getIncomeEntries() async {
    return getEntriesByType('Gelir');
  }

  /// Get expense entries
  Future<List<IncomeExpenseEntry>> getExpenseEntries() async {
    return getEntriesByType('Gider');
  }

  /// Get entries by date range
  Future<List<IncomeExpenseEntry>> getEntriesByDateRange(
    DateTime startDate,
    DateTime endDate,
  ) async {
    try {
      final db = await _dbConnection.database;
      final List<Map<String, dynamic>> maps = await db.query(
        tableName,
        where: '$columnDate BETWEEN ? AND ?',
        whereArgs: [
          startDate.toIso8601String(),
          endDate.toIso8601String(),
        ],
        orderBy: '$columnDate DESC',
      );

      final entries = maps.map((map) => _mapToModel(map)).toList();
      Logger.info('Retrieved ${entries.length} entries for date range', tag: 'INCOME_EXPENSE_REPOSITORY');
      return entries;
    } catch (e) {
      Logger.error('Failed to get entries by date range', tag: 'INCOME_EXPENSE_REPOSITORY', error: e);
      rethrow;
    }
  }

  /// Get entries by category
  Future<List<IncomeExpenseEntry>> getEntriesByCategory(String category) async {
    try {
      final db = await _dbConnection.database;
      final List<Map<String, dynamic>> maps = await db.query(
        tableName,
        where: '$columnCategory = ?',
        whereArgs: [category],
        orderBy: '$columnDate DESC',
      );

      final entries = maps.map((map) => _mapToModel(map)).toList();
      Logger.info('Retrieved ${entries.length} entries for category: $category', tag: 'INCOME_EXPENSE_REPOSITORY');
      return entries;
    } catch (e) {
      Logger.error('Failed to get entries by category', tag: 'INCOME_EXPENSE_REPOSITORY', error: e);
      rethrow;
    }
  }

  /// Search entries by description
  Future<List<IncomeExpenseEntry>> searchByDescription(String query) async {
    try {
      final db = await _dbConnection.database;
      final List<Map<String, dynamic>> maps = await db.query(
        tableName,
        where: '$columnDescription LIKE ?',
        whereArgs: ['%$query%'],
        orderBy: '$columnDate DESC',
      );

      final entries = maps.map((map) => _mapToModel(map)).toList();
      Logger.info('Found ${entries.length} entries for query: $query', tag: 'INCOME_EXPENSE_REPOSITORY');
      return entries;
    } catch (e) {
      Logger.error('Failed to search entries', tag: 'INCOME_EXPENSE_REPOSITORY', error: e);
      rethrow;
    }
  }

  /// Get entry by ID
  Future<IncomeExpenseEntry?> getById(String id) async {
    try {
      final db = await _dbConnection.database;
      final List<Map<String, dynamic>> maps = await db.query(
        tableName,
        where: '$columnId = ?',
        whereArgs: [id],
        limit: 1,
      );

      if (maps.isEmpty) {
        Logger.warn('Income/expense entry not found: $id', tag: 'INCOME_EXPENSE_REPOSITORY');
        return null;
      }

      final entry = _mapToModel(maps.first);
      Logger.info('Retrieved income/expense entry: ${entry.description}', tag: 'INCOME_EXPENSE_REPOSITORY');
      return entry;
    } catch (e) {
      Logger.error('Failed to get income/expense entry by ID', tag: 'INCOME_EXPENSE_REPOSITORY', error: e);
      rethrow;
    }
  }

  /// Insert new income/expense entry
  Future<bool> insert(IncomeExpenseEntry entry) async {
    try {
      final db = await _dbConnection.database;
      final now = DateTime.now().toIso8601String();
      
      await db.insert(
        tableName,
        {
          columnId: entry.id,
          columnDescription: entry.description,
          columnAmount: entry.amount,
          columnType: entry.type,
          columnDate: entry.date.toIso8601String(),
          columnCategory: entry.category,
          columnIsAutoGenerated: entry.isAutoGenerated ? 1 : 0,
          columnCreatedAt: now,
          columnUpdatedAt: now,
        },
        conflictAlgorithm: ConflictAlgorithm.replace,
      );

      Logger.success('Income/expense entry inserted: ${entry.description}', tag: 'INCOME_EXPENSE_REPOSITORY');
      return true;
    } catch (e) {
      Logger.error('Failed to insert income/expense entry', tag: 'INCOME_EXPENSE_REPOSITORY', error: e);
      return false;
    }
  }

  /// Update existing income/expense entry
  Future<bool> update(IncomeExpenseEntry entry) async {
    try {
      final db = await _dbConnection.database;
      final now = DateTime.now().toIso8601String();
      
      final rowsAffected = await db.update(
        tableName,
        {
          columnDescription: entry.description,
          columnAmount: entry.amount,
          columnType: entry.type,
          columnDate: entry.date.toIso8601String(),
          columnCategory: entry.category,
          columnIsAutoGenerated: entry.isAutoGenerated ? 1 : 0,
          columnUpdatedAt: now,
        },
        where: '$columnId = ?',
        whereArgs: [entry.id],
      );

      if (rowsAffected > 0) {
        Logger.success('Income/expense entry updated: ${entry.description}', tag: 'INCOME_EXPENSE_REPOSITORY');
        return true;
      } else {
        Logger.warn('No income/expense entry found to update: ${entry.id}', tag: 'INCOME_EXPENSE_REPOSITORY');
        return false;
      }
    } catch (e) {
      Logger.error('Failed to update income/expense entry', tag: 'INCOME_EXPENSE_REPOSITORY', error: e);
      return false;
    }
  }

  /// Delete income/expense entry
  Future<bool> delete(String id) async {
    try {
      final db = await _dbConnection.database;
      final rowsAffected = await db.delete(
        tableName,
        where: '$columnId = ?',
        whereArgs: [id],
      );

      if (rowsAffected > 0) {
        Logger.success('Income/expense entry deleted: $id', tag: 'INCOME_EXPENSE_REPOSITORY');
        return true;
      } else {
        Logger.warn('No income/expense entry found to delete: $id', tag: 'INCOME_EXPENSE_REPOSITORY');
        return false;
      }
    } catch (e) {
      Logger.error('Failed to delete income/expense entry', tag: 'INCOME_EXPENSE_REPOSITORY', error: e);
      return false;
    }
  }

  /// Get all categories
  Future<List<String>> getCategories() async {
    try {
      final db = await _dbConnection.database;
      final List<Map<String, dynamic>> maps = await db.rawQuery(
        'SELECT DISTINCT $columnCategory FROM $tableName WHERE $columnCategory IS NOT NULL ORDER BY $columnCategory'
      );

      final categories = maps
          .map((map) => map[columnCategory] as String)
          .where((category) => category.isNotEmpty)
          .toList();

      Logger.info('Retrieved ${categories.length} categories', tag: 'INCOME_EXPENSE_REPOSITORY');
      return categories;
    } catch (e) {
      Logger.error('Failed to get categories', tag: 'INCOME_EXPENSE_REPOSITORY', error: e);
      return [];
    }
  }

  /// Get financial summary
  Future<Map<String, dynamic>> getFinancialSummary() async {
    try {
      final db = await _dbConnection.database;
      
      final incomeResult = await db.rawQuery(
        'SELECT SUM($columnAmount) as total FROM $tableName WHERE $columnType = "Gelir"',
      );
      
      final expenseResult = await db.rawQuery(
        'SELECT SUM($columnAmount) as total FROM $tableName WHERE $columnType = "Gider"',
      );

      final totalIncome = incomeResult.first['total'] as double? ?? 0.0;
      final totalExpense = expenseResult.first['total'] as double? ?? 0.0;
      final netIncome = totalIncome - totalExpense;

      final summary = {
        'totalIncome': totalIncome,
        'totalExpense': totalExpense,
        'netIncome': netIncome,
      };

      Logger.info('Financial summary calculated', tag: 'INCOME_EXPENSE_REPOSITORY');
      return summary;
    } catch (e) {
      Logger.error('Failed to get financial summary', tag: 'INCOME_EXPENSE_REPOSITORY', error: e);
      return {
        'totalIncome': 0.0,
        'totalExpense': 0.0,
        'netIncome': 0.0,
      };
    }
  }

  /// Get monthly summaries
  Future<List<Map<String, dynamic>>> getMonthlySummaries(int year) async {
    try {
      final db = await _dbConnection.database;
      final result = await db.rawQuery('''
        SELECT 
          strftime('%m', $columnDate) as month,
          SUM(CASE WHEN $columnType = 'Gelir' THEN $columnAmount ELSE 0 END) as income,
          SUM(CASE WHEN $columnType = 'Gider' THEN $columnAmount ELSE 0 END) as expense
        FROM $tableName 
        WHERE strftime('%Y', $columnDate) = ?
        GROUP BY strftime('%m', $columnDate)
        ORDER BY month
      ''', [year.toString()]);

      final summaries = result.map((row) {
        final income = row['income'] as double? ?? 0.0;
        final expense = row['expense'] as double? ?? 0.0;
        return {
          'month': int.parse(row['month'] as String),
          'income': income,
          'expense': expense,
          'net': income - expense,
        };
      }).toList();

      Logger.info('Retrieved ${summaries.length} monthly summaries for $year', tag: 'INCOME_EXPENSE_REPOSITORY');
      return summaries;
    } catch (e) {
      Logger.error('Failed to get monthly summaries', tag: 'INCOME_EXPENSE_REPOSITORY', error: e);
      return [];
    }
  }

  /// Bulk insert income/expense entries
  Future<bool> insertBulk(List<IncomeExpenseEntry> entries) async {
    try {
      final db = await _dbConnection.database;
      final batch = db.batch();
      final now = DateTime.now().toIso8601String();

      for (final entry in entries) {
        batch.insert(
          tableName,
          {
            columnId: entry.id,
            columnDescription: entry.description,
            columnAmount: entry.amount,
            columnType: entry.type,
            columnDate: entry.date.toIso8601String(),
            columnCategory: entry.category,
            columnIsAutoGenerated: entry.isAutoGenerated ? 1 : 0,
            columnCreatedAt: now,
            columnUpdatedAt: now,
          },
          conflictAlgorithm: ConflictAlgorithm.replace,
        );
      }

      await batch.commit();
      Logger.success('Bulk inserted ${entries.length} income/expense entries', tag: 'INCOME_EXPENSE_REPOSITORY');
      return true;
    } catch (e) {
      Logger.error('Failed to bulk insert income/expense entries', tag: 'INCOME_EXPENSE_REPOSITORY', error: e);
      return false;
    }
  }

  /// Convert database map to IncomeExpenseEntry model
  IncomeExpenseEntry _mapToModel(Map<String, dynamic> map) {
    return IncomeExpenseEntry(
      id: map[columnId] as String,
      description: map[columnDescription] as String,
      amount: (map[columnAmount] as num).toDouble(),
      type: map[columnType] as String,
      date: DateTime.parse(map[columnDate] as String),
      category: map[columnCategory] as String,
      isAutoGenerated: (map[columnIsAutoGenerated] as int) == 1,
    );
  }
} 