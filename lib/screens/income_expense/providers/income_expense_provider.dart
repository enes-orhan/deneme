import 'package:flutter/foundation.dart';
import '../../../models/income_expense_entry.dart';
import '../../../services/database/repositories/income_expense_repository.dart';
import '../../../utils/logger.dart';
import 'package:uuid/uuid.dart';

/// Provider for income/expense management using SQLite repository
/// Handles all financial entry operations with proper state management
class IncomeExpenseProvider extends ChangeNotifier {
  final IncomeExpenseRepository _repository = IncomeExpenseRepository();
  
  List<IncomeExpenseEntry> _allEntries = [];
  List<IncomeExpenseEntry> _filteredEntries = [];
  bool _isLoading = false;
  String _searchQuery = '';
  String _errorMessage = '';
  String _selectedType = 'Tümü'; // Tümü, Gelir, Gider
  String _selectedCategory = 'Tümü';

  // Getters
  List<IncomeExpenseEntry> get allEntries => _allEntries;
  List<IncomeExpenseEntry> get filteredEntries => _filteredEntries;
  bool get isLoading => _isLoading;
  String get searchQuery => _searchQuery;
  String get errorMessage => _errorMessage;
  String get selectedType => _selectedType;
  String get selectedCategory => _selectedCategory;

  /// Get total income amount
  double get totalIncome {
    return _allEntries
        .where((entry) => entry.type == 'Gelir')
        .fold(0.0, (sum, entry) => sum + entry.amount);
  }

  /// Get total expense amount
  double get totalExpense {
    return _allEntries
        .where((entry) => entry.type == 'Gider')
        .fold(0.0, (sum, entry) => sum + entry.amount);
  }

  /// Get net income (income - expense)
  double get netIncome => totalIncome - totalExpense;

  /// Get income entries count
  int get incomeCount {
    return _allEntries.where((entry) => entry.type == 'Gelir').length;
  }

  /// Get expense entries count
  int get expenseCount {
    return _allEntries.where((entry) => entry.type == 'Gider').length;
  }

  /// Initialize provider and load data
  Future<void> initialize() async {
    await loadEntries();
  }

  /// Load all income/expense entries from database
  Future<void> loadEntries() async {
    _setLoading(true);
    _clearError();

    try {
      _allEntries = await _repository.getAllEntries();
      _applyFilters();
      Logger.info('Loaded ${_allEntries.length} income/expense entries', tag: 'INCOME_EXPENSE_PROVIDER');
    } catch (e) {
      _setError('Gelir/gider kayıtları yüklenirken hata oluştu: $e');
      Logger.error('Failed to load income/expense entries', tag: 'INCOME_EXPENSE_PROVIDER', error: e);
    } finally {
      _setLoading(false);
    }
  }

  /// Add new income/expense entry
  Future<bool> addEntry({
    required String description,
    required double amount,
    required String type, // Gelir or Gider
    required String category,
    DateTime? date,
    bool isAutoGenerated = false,
  }) async {
    _clearError();

    if (amount <= 0) {
      _setError('Tutar sıfırdan büyük olmalıdır');
      return false;
    }

    try {
      final entry = IncomeExpenseEntry(
        id: const Uuid().v4(),
        description: description.trim(),
        amount: amount,
        type: type,
        category: category,
        date: date ?? DateTime.now(),
        isAutoGenerated: isAutoGenerated,
      );

      final success = await _repository.insert(entry);
      if (success) {
        await loadEntries(); // Refresh data
        Logger.success('Income/expense entry added: $description', tag: 'INCOME_EXPENSE_PROVIDER');
        return true;
      } else {
        _setError('Kayıt eklenirken hata oluştu');
        return false;
      }
    } catch (e) {
      _setError('Kayıt eklenirken hata oluştu: $e');
      Logger.error('Failed to add income/expense entry', tag: 'INCOME_EXPENSE_PROVIDER', error: e);
      return false;
    }
  }

  /// Delete income/expense entry
  Future<bool> deleteEntry(String entryId) async {
    _clearError();

    try {
      final success = await _repository.delete(entryId);
      if (success) {
        await loadEntries(); // Refresh data
        Logger.success('Income/expense entry deleted', tag: 'INCOME_EXPENSE_PROVIDER');
        return true;
      } else {
        _setError('Kayıt silinirken hata oluştu');
        return false;
      }
    } catch (e) {
      _setError('Kayıt silinirken hata oluştu: $e');
      Logger.error('Failed to delete income/expense entry', tag: 'INCOME_EXPENSE_PROVIDER', error: e);
      return false;
    }
  }

  /// Search entries by description
  void searchEntries(String query) {
    _searchQuery = query.trim().toLowerCase();
    _applyFilters();
    Logger.info('Searching entries with query: $_searchQuery', tag: 'INCOME_EXPENSE_PROVIDER');
  }

  /// Filter entries by type (Tümü, Gelir, Gider)
  void filterByType(String type) {
    _selectedType = type;
    _applyFilters();
    Logger.info('Filtering by type: $type', tag: 'INCOME_EXPENSE_PROVIDER');
  }

  /// Filter entries by category
  void filterByCategory(String category) {
    _selectedCategory = category;
    _applyFilters();
    Logger.info('Filtering by category: $category', tag: 'INCOME_EXPENSE_PROVIDER');
  }

  /// Clear all filters
  void clearFilters() {
    _searchQuery = '';
    _selectedType = 'Tümü';
    _selectedCategory = 'Tümü';
    _applyFilters();
  }

  /// Get financial summary
  Future<Map<String, dynamic>> getFinancialSummary() async {
    try {
      return await _repository.getFinancialSummary();
    } catch (e) {
      Logger.error('Failed to get financial summary', tag: 'INCOME_EXPENSE_PROVIDER', error: e);
      return {
        'totalIncome': 0.0,
        'totalExpense': 0.0,
        'netIncome': 0.0,
      };
    }
  }

  /// Get entries by date range
  Future<List<IncomeExpenseEntry>> getEntriesByDateRange(
    DateTime startDate,
    DateTime endDate,
  ) async {
    try {
      return await _repository.getEntriesByDateRange(startDate, endDate);
    } catch (e) {
      Logger.error('Failed to get entries by date range', tag: 'INCOME_EXPENSE_PROVIDER', error: e);
      return [];
    }
  }

  /// Import entries from CSV data
  Future<bool> importFromCsv(List<IncomeExpenseEntry> entries) async {
    _clearError();

    try {
      final success = await _repository.insertBulk(entries);
      if (success) {
        await loadEntries(); // Refresh data
        Logger.success('Imported ${entries.length} income/expense entries', tag: 'INCOME_EXPENSE_PROVIDER');
        return true;
      } else {
        _setError('CSV verisi içe aktarılırken hata oluştu');
        return false;
      }
    } catch (e) {
      _setError('CSV verisi içe aktarılırken hata oluştu: $e');
      Logger.error('Failed to import CSV data', tag: 'INCOME_EXPENSE_PROVIDER', error: e);
      return false;
    }
  }

  /// Export entries to CSV data
  List<IncomeExpenseEntry> exportToCsv() {
    return List.from(_allEntries);
  }

  /// Get available categories from existing entries
  List<String> getAvailableCategories() {
    final categories = _allEntries
        .map((entry) => entry.category)
        .where((category) => category.isNotEmpty)
        .toSet()
        .toList();
    categories.sort();
    return ['Tümü', ...categories];
  }

  /// Apply search and filter logic
  void _applyFilters() {
    List<IncomeExpenseEntry> filtered = List.from(_allEntries);

    // Filter by type
    if (_selectedType != 'Tümü') {
      filtered = filtered.where((entry) => entry.type == _selectedType).toList();
    }

    // Filter by category
    if (_selectedCategory != 'Tümü') {
      filtered = filtered.where((entry) => entry.category == _selectedCategory).toList();
    }

    // Apply search filter
    if (_searchQuery.isNotEmpty) {
      filtered = filtered.where((entry) {
        return entry.description.toLowerCase().contains(_searchQuery);
      }).toList();
    }

    // Sort by date (newest first)
    filtered.sort((a, b) => b.date.compareTo(a.date));

    _filteredEntries = filtered;
    notifyListeners();
  }

  /// Set loading state
  void _setLoading(bool loading) {
    if (_isLoading != loading) {
      _isLoading = loading;
      notifyListeners();
    }
  }

  /// Set error message
  void _setError(String message) {
    _errorMessage = message;
    notifyListeners();
  }

  /// Clear error message
  void _clearError() {
    if (_errorMessage.isNotEmpty) {
      _errorMessage = '';
      notifyListeners();
    }
  }
} 