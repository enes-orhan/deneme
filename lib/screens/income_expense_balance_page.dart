import 'package:flutter/material.dart';
import '../models/income_expense_entry.dart';
import '../models/credit_entry.dart';
import '../constants/app_constants.dart';
import '../services/storage_service.dart';
import 'income_expense_details_page.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'dart:convert';
import 'package:intl/intl.dart';

class IncomeExpenseBalancePage extends StatefulWidget {
  final StorageService storageService;

  const IncomeExpenseBalancePage({
    Key? key,
    required this.storageService,
  }) : super(key: key);

  @override
  State<IncomeExpenseBalancePage> createState() => _IncomeExpenseBalancePageState();
}

class _IncomeExpenseBalancePageState extends State<IncomeExpenseBalancePage> {
  List<IncomeExpenseEntry> _entries = [];
  bool _isLoading = true;
  Map<IncomeExpenseCategory, double> _categoryTotals = {};
  Map<String, double> _dailyIncome = {};
  Map<String, double> _dailyExpense = {};

  @override
  void initState() {
    super.initState();
    _loadData();
  }

  Future<void> _loadData() async {
    setState(() => _isLoading = true);
    try {
      final sales = await widget.storageService.getSales();
      final expenses = await widget.storageService.getExpenses();
      
      // Satışları tarihe göre grupla
      final dailySales = <String, Map<String, dynamic>>{};
      for (final sale in sales) {
        if (sale['type'] == 'summary') {
          final date = sale['date'] ?? '';
          if (date.isNotEmpty) {
            dailySales[date] = sale;
          }
        }
      }

      // Günlük gelir ve giderleri hesapla
      final dailyIncome = <String, double>{};
      final dailyExpense = <String, double>{};

      // Satışlardan gelen gelirleri ekle
      for (final entry in dailySales.entries) {
        final date = entry.key;
        final sale = entry.value;
        
        final cashAmount = double.tryParse(sale['cashAmount']?.toString() ?? '0') ?? 0.0;
        final cardAmount = double.tryParse(sale['cardAmount']?.toString() ?? '0') ?? 0.0;
        final marketAmount = double.tryParse(sale['marketAmount']?.toString() ?? '0') ?? 0.0;
        final totalIncome = cashAmount + cardAmount + marketAmount;
        
        dailyIncome[date] = totalIncome;
        
        // Maliyetleri gider olarak ekle
        final totalCost = double.tryParse(sale['totalCost']?.toString() ?? '0') ?? 0.0;
        dailyExpense[date] = totalCost;
      }

      // Diğer giderleri ekle
      for (final expense in expenses) {
        final date = expense['date'] ?? '';
        if (date.isNotEmpty) {
          final amount = double.tryParse(expense['amount']?.toString() ?? '0') ?? 0.0;
          dailyExpense[date] = (dailyExpense[date] ?? 0) + amount;
        }
      }

      setState(() {
        _dailyIncome = dailyIncome;
        _dailyExpense = dailyExpense;
        _isLoading = false;
      });
    } catch (e) {
      print('Veri yükleme hatası: $e');
      setState(() => _isLoading = false);
      _showError('Veriler yüklenirken bir hata oluştu: $e');
    }
  }

  Future<void> _updateAutoGeneratedData() async {
    try {
      final sales = await widget.storageService.getSales();
      final products = await widget.storageService.getProducts();
      final receivables = await widget.storageService.getReceivables();
      final creditEntries = await _getCreditEntries();

      // Günlük satış geliri ve maliyeti hesapla
      final today = DateTime.now();
      final todayString = "${today.year}-${today.month.toString().padLeft(2, '0')}-${today.day.toString().padLeft(2, '0')}";
      
      // Satış özeti bilgilerini buluyoruz
      final dailySummaries = sales.where((s) => 
        s['type'] == 'summary' && 
        s['date'] != null && 
        s['date'].toString().contains(todayString)
      ).toList();
      
      // Toplam gelir hesapla (tahsilat)
      double totalIncome = 0.0;
      double totalCost = 0.0;
      
      // Eğer bugün için satış özeti varsa, onun verilerini kullan
      if (dailySummaries.isNotEmpty) {
        // En son özeti al
        final latestSummary = dailySummaries.reduce((a, b) {
          final aDate = a['timestamp'] != null ? 
            DateTime.tryParse(a['timestamp'].toString()) ?? DateTime.now() : 
            DateTime.now();
          final bDate = b['timestamp'] != null ? 
            DateTime.tryParse(b['timestamp'].toString()) ?? DateTime.now() : 
            DateTime.now();
          return aDate.isAfter(bDate) ? a : b;
        });
        
        // Özet içindeki toplam gelir ve gider değerlerini al
        totalIncome = (latestSummary['totalIncome'] ?? latestSummary['cashAmount'] ?? 0.0) is num ? 
          (latestSummary['totalIncome'] ?? latestSummary['cashAmount'] ?? 0.0) as double : 
          double.tryParse(latestSummary['totalIncome']?.toString() ?? latestSummary['cashAmount']?.toString() ?? '0.0') ?? 0.0;
        
        totalCost = latestSummary['totalCost'] is num ? 
          (latestSummary['totalCost'] as num).toDouble() : 
          double.tryParse(latestSummary['totalCost']?.toString() ?? '0.0') ?? 0.0;
      } else {
        // Özet yoksa bugünkü tüm satışları topla
        final todaySales = sales.where((s) {
          if (s['type'] == 'summary') return false; // Özet kayıtları dahil etme
          final saleDate = s['timestamp'] != null
            ? DateTime.tryParse(s['timestamp'].toString()) ?? DateTime.now()
            : DateTime.now();
          return saleDate.year == today.year &&
                saleDate.month == today.month &&
                saleDate.day == today.day;
        }).toList();
        
        totalIncome = todaySales.fold(0.0, (sum, sale) => 
          sum + ((sale['price'] ?? 0) as num) * ((sale['quantity'] ?? 0) as num)
        );
        
        totalCost = todaySales.fold(0.0, (sum, sale) => 
          sum + ((sale['finalCost'] ?? sale['price'] ?? 0) as num) * ((sale['quantity'] ?? 0) as num)
        );
      }

      // Stok değerini hesapla
      final totalStockValue = products.fold(0.0, (sum, product) => 
        sum + (product.finalCost * product.quantity)
      );

      // Alacakları hesapla
      final totalReceivables = receivables.fold(0.0, (sum, receivable) => 
        sum + (receivable.isPaid ? 0 : receivable.amount)
      );
      
      // Veresiye defterinden alacakları hesapla
      double totalCreditReceivables = 0.0;
      for (var entry in creditEntries) {
        totalCreditReceivables += entry.remainingDebt;
      }

      // Mevcut otomatik kayıtları al
      final existingEntries = await widget.storageService.getIncomeExpenseEntries();
      final autoEntries = existingEntries.where((e) => e.isAutoGenerated).toList();

      // Otomatik kayıtları güncelle
      final updatedAutoEntries = [
        _updateOrCreateAutoEntry(
          autoEntries,
          'daily_income_${today.toString().split(' ')[0]}',
          'gelir', // EntryType.gelir ile eşleşecek
          'gunlukGelir', // IncomeExpenseCategory ile eşleşecek
          'Günlük Toplam Tahsilat (${today.day}.${today.month}.${today.year})',
          totalIncome,
          today,
        ),
        _updateOrCreateAutoEntry(
          autoEntries,
          'daily_expense_${today.toString().split(' ')[0]}',
          'gider', // EntryType.gider ile eşleşecek
          'gunlukGider', // IncomeExpenseCategory ile eşleşecek
          'Günlük Toplam Maliyet (${today.day}.${today.month}.${today.year})',
          totalCost,
          today,
        ),
        _updateOrCreateAutoEntry(
          autoEntries,
          'stock_${today.toString().split(' ')[0]}',
          'mevcut', // EntryType.mevcut ile eşleşecek
          'stok', // IncomeExpenseCategory ile eşleşecek
          'Mevcut Stok Değeri',
          totalStockValue,
          today,
        ),
        _updateOrCreateAutoEntry(
          autoEntries,
          'receivables_${today.toString().split(' ')[0]}',
          'mevcut', // EntryType.mevcut ile eşleşecek
          'alacak', // IncomeExpenseCategory ile eşleşecek
          'Toplam Alacak',
          totalReceivables + totalCreditReceivables,
          today,
        ),
      ];

      // Otomatik olmayan kayıtları koru
      final manualEntries = existingEntries.where((e) => !e.isAutoGenerated).toList();
      
      // Tüm kayıtları birleştir ve kaydet
      final allEntries = [...manualEntries, ...updatedAutoEntries];
      await _saveAllEntries(allEntries);
    } catch (e) {
      print('Otomatik veri güncelleme hatası: $e');
      rethrow;
    }
  }

  Future<List<CreditEntry>> _getCreditEntries() async {
    final prefs = await SharedPreferences.getInstance();
    final data = prefs.getStringList('credit_entries') ?? [];
    return data.map((e) => CreditEntry.fromMap(jsonDecode(e))).toList();
  }

  Future<void> _saveAllEntries(List<IncomeExpenseEntry> entries) async {
    final prefs = await SharedPreferences.getInstance();
    final entriesJson = entries.map((e) => jsonEncode(e.toMap())).toList();
    await prefs.setStringList('income_expense_entries', entriesJson);
  }

  IncomeExpenseEntry _updateOrCreateAutoEntry(
    List<IncomeExpenseEntry> existingEntries,
    String id,
    String type,
    String category,
    String description,
    double amount,
    DateTime date,
  ) {
    // Enum adlarını düzgün ayarlayalım
    final entryType = EntryType.values.firstWhere(
      (e) => e.name == type,
      orElse: () => EntryType.gelir,
    );
    
    final categoryEnum = IncomeExpenseCategory.values.firstWhere(
      (c) => c.name == category,
      orElse: () => IncomeExpenseCategory.gunlukGelir,
    );

    final existingEntry = existingEntries.firstWhere(
      (e) => e.id == id,
      orElse: () => IncomeExpenseEntry(
        id: id,
        type: entryType.name,
        category: categoryEnum.name,
        description: description,
        amount: amount,
        date: date,
        isAutoGenerated: true,
      ),
    );

    return IncomeExpenseEntry(
      id: existingEntry.id,
      type: entryType.name,
      category: categoryEnum.name,
      description: description,
      amount: amount,
      date: date,
      isAutoGenerated: true,
    );
  }

  void _calculateTotals() {
    _categoryTotals.clear();
    for (var category in IncomeExpenseCategory.values) {
      final total = _entries
          .where((e) => e.category == category.name)
          .fold(0.0, (sum, e) => sum + e.amount);
      _categoryTotals[category] = total;
    }
  }

  void _showError(String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: AppColors.error,
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Bilanço'),
        backgroundColor: AppColors.primary,
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: _loadData,
            tooltip: 'Yenile',
          ),
        ],
      ),
      body: _isLoading
          ? const Center(child: CircularProgressIndicator())
          : Padding(
              padding: const EdgeInsets.all(16.0),
              child: GridView.count(
                crossAxisCount: MediaQuery.of(context).size.width > 600 ? 2 : 1,
                crossAxisSpacing: 16,
                mainAxisSpacing: 16,
                childAspectRatio: 1.7,
                children: [
                  _buildBalanceCard(
                    context,
                    title: 'Gelirler',
                    color: Colors.green.shade100,
                    icon: Icons.trending_up,
                    iconColor: Colors.green,
                    categories: [
                      IncomeExpenseCategory.sabitGelir,
                      IncomeExpenseCategory.gunlukGelir,
                    ],
                  ),
                  _buildBalanceCard(
                    context,
                    title: 'Giderler',
                    color: Colors.red.shade100,
                    icon: Icons.trending_down,
                    iconColor: Colors.red,
                    categories: [
                      IncomeExpenseCategory.sabitGider,
                      IncomeExpenseCategory.gunlukGider,
                    ],
                  ),
                  _buildBalanceCard(
                    context,
                    title: 'Mevcutlar',
                    color: Colors.blue.shade100,
                    icon: Icons.account_balance_wallet,
                    iconColor: Colors.blue,
                    categories: [
                      IncomeExpenseCategory.nakit,
                      IncomeExpenseCategory.alacak,
                      IncomeExpenseCategory.stok,
                    ],
                  ),
                  _buildBalanceCard(
                    context,
                    title: 'Borçlar',
                    color: Colors.orange.shade100,
                    icon: Icons.warning,
                    iconColor: Colors.orange,
                    categories: [
                      IncomeExpenseCategory.bankaBorcu,
                      IncomeExpenseCategory.toptanciBorcu,
                      IncomeExpenseCategory.tlBorcu,
                      IncomeExpenseCategory.dovizBorcu,
                      IncomeExpenseCategory.emtiaBorcu,
                    ],
                  ),
                ],
              ),
            ),
    );
  }

  Widget _buildBalanceCard(
    BuildContext context, {
    required String title,
    required Color color,
    required IconData icon,
    required Color iconColor,
    required List<IncomeExpenseCategory> categories,
  }) {
    final total = categories.fold(0.0, (sum, category) => sum + (_categoryTotals[category] ?? 0));
    final entries = _entries.where((e) => categories.contains(e.category)).toList();

    return Card(
      color: color,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      elevation: 4,
      child: Stack(
        children: [
          Padding(
            padding: const EdgeInsets.all(20.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Icon(icon, color: iconColor, size: 32),
                    const SizedBox(width: 12),
                    Text(title, style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold, color: iconColor)),
                  ],
                ),
                const SizedBox(height: 16),
                Text('${total.toStringAsFixed(2)} TL', style: TextStyle(fontSize: 28, fontWeight: FontWeight.bold, color: iconColor)),
                const SizedBox(height: 12),
                Expanded(
                  child: ListView.builder(
                    shrinkWrap: true,
                    itemCount: categories.length,
                    itemBuilder: (context, index) {
                      final category = categories[index];
                      final categoryTotal = _categoryTotals[category] ?? 0;
                      final categoryEntries = entries.where((e) => e.category == category.name).toList();
                      return Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Row(
                            mainAxisAlignment: MainAxisAlignment.spaceBetween,
                            children: [
                              Text(
                                _getCategoryLabel(category),
                                style: TextStyle(fontWeight: FontWeight.bold),
                              ),
                              Text('${categoryTotal.toStringAsFixed(2)} TL'),
                            ],
                          ),
                          if (categoryEntries.isNotEmpty)
                            ...categoryEntries.map((e) => Padding(
                              padding: const EdgeInsets.only(left: 8, top: 4),
                              child: Row(
                                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                children: [
                                  Expanded(
                                    child: Text(
                                      e.description,
                                      style: TextStyle(fontSize: 12),
                                      overflow: TextOverflow.ellipsis,
                                    ),
                                  ),
                                  Text(
                                    '${e.amount.toStringAsFixed(2)} TL',
                                    style: TextStyle(fontSize: 12),
                                  ),
                                ],
                              ),
                            )),
                          const SizedBox(height: 8),
                        ],
                      );
                    },
                  ),
                ),
              ],
            ),
          ),
          // Detaylar butonu sağ alt köşede
          Positioned(
            bottom: 8,
            right: 8,
            child: ElevatedButton.icon(
              style: ElevatedButton.styleFrom(
                backgroundColor: iconColor.withOpacity(0.9),
                foregroundColor: Colors.white,
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
                elevation: 2,
                padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              ),
              icon: const Icon(Icons.info_outline),
              label: const Text('Detaylar'),
              onPressed: () {
                Navigator.push(
                  context,
                  MaterialPageRoute(
                    builder: (context) => IncomeExpenseDetailsPage(
                      type: _getTypeByTitle(title),
                      entries: entries,
                      storageService: widget.storageService,
                    ),
                  ),
                ).then((_) => _loadData());
              },
            ),
          ),
        ],
      ),
    );
  }

  String _getCategoryLabel(IncomeExpenseCategory category) {
    switch (category) {
      case IncomeExpenseCategory.sabitGelir:
        return 'Sabit Gelirler';
      case IncomeExpenseCategory.gunlukGelir:
        return 'Günlük Gelirler';
      case IncomeExpenseCategory.sabitGider:
        return 'Sabit Giderler';
      case IncomeExpenseCategory.gunlukGider:
        return 'Günlük Giderler';
      case IncomeExpenseCategory.nakit:
        return 'Eldeki Nakit';
      case IncomeExpenseCategory.alacak:
        return 'Alacaklar';
      case IncomeExpenseCategory.stok:
        return 'Toplam Stok';
      case IncomeExpenseCategory.bankaBorcu:
        return 'Banka Borcu';
      case IncomeExpenseCategory.toptanciBorcu:
        return 'Toptancı Borcu';
      case IncomeExpenseCategory.tlBorcu:
        return 'TL ile Borç';
      case IncomeExpenseCategory.dovizBorcu:
        return 'Döviz Borcu';
      case IncomeExpenseCategory.emtiaBorcu:
        return 'Emtia Borcu';
    }
  }

  EntryType _getTypeByTitle(String title) {
    switch (title) {
      case 'Gelirler':
        return EntryType.gelir;
      case 'Giderler':
        return EntryType.gider;
      case 'Mevcutlar':
        return EntryType.mevcut;
      case 'Borçlar':
        return EntryType.borc;
      default:
        return EntryType.gelir;
    }
  }
} 